## Работа с Терминалом

### Команды
* clear - очистить экран от содержимого
* ls - показать файлы в папке
* cd - открыть папку (указать название папки)
* cd .. - открыть родительскую папку
* touch - создать новый файл (указать название файла и при необходимости указать расширение)
* клавиши ctrl + shift + x - сохранение изменений
* клавиша tab - дозаполнить текст, который вы недописали
* клавиши ВВЕРХ и ВНИЗ - перебор значений, которые мы вводили недавно
* клавиша q - выход в режим ввода, если он недоступен
* несколько команд можно объединить знаком &&, например, touch 1.rb && git add 1.rb && git commit -m "Commit 1"
* ruby - запустить программу (указать название файла с расширением .rb)
* irb - запустить интерактивную консоль Ruby (устанавливается вместе с Ruby)
* ./rubymine.sh - запуск редактора RubyMine

## Работа с Ruby

### Комментарий к курсу
* код в виде столбца будет здесь для удобства отображаться одной строкой, новая строка обозначается знаком /
* пример: def price=(value) / @price = value / end
* результат работы программы будет здесь отображаться после знака =>

### Оглавление
* [пример: Теория, переменные](theory/variables.rb)
* [пример: Теория, операторы](theory/operators.rb)
* [пример: Теория, условные выражения](theory/conditional.rb)
* [пример: Теория, циклы](theory/cycles.rb)
* [пример: Теория, массивы](theory/array.rb)
* [пример: Теория, ассоциативные массивы](theory/hash.rb)
* [пример: Теория, методы](theory/methods.rb)
* [пример: Теория, блоки](theory/blocks.rb)
* [пример: Теория, руководство по Ruby](theory/ruby_tutorial.rb)
* [пример: Интернет-магазин](online_store/init.rb)
* [пример: Интернет-магазин, товары](online_store/item.rb)
* [пример: Интернет-магазин, обычные товары](online_store/real_item.rb)
* [пример: Интернет-магазин, виртуальные товары](online_store/virtual_item.rb)
* [пример: Интернет-магазин, контейнер для товаров](online_store/item_container.rb)
* [пример: Интернет-магазин, корзина](online_store/cart.rb)
* [пример: Интернет-магазин, заказы](online_store/order.rb)
* [пример: Интернет-магазин, пользователи](online_store/user.rb)
* [пример: Эксперименты, приём на работу](experiments/recruitment.rb)
* [пример: Wordbook](wordbook/wordbook.rb)

### Типы данных
* **NilClass** - объект nil
* **TrueClass**, **FalseClass** -  логический тип данных - true, false
* **Numeric** - числа, делятся на **Integer**, **Float** и **Complex**
* **Integer** - целые числа, делятся на **Fixnum** и **Bignum**, можно использовать знак "_" внутри числа для удобства чтения больших чисел
* **Fixnum** - целые числа меньше 2^30
* **Bignum** - целые числа больше 2^30
* **Float** - числа с плавающей точкой - содержат "." после числа
* **Complex** - комплексные числа
* **String** - строки - берутся в '' или ""
* **Symbol** - символы - действуют как метка или идентификатор, неизменяемы, выглядят как объявление переменной без значения
* **Array** - массивы - обозначаются в []
* **Hash** - ассоциативные массивы (хэши) - обозначаются в {}, представляют собой наборы ключей и значений, рекомендуется использовать в качестве ключей символы
* **Range** - диапазоны, примеры: 1..100 (значения от 1 до 100), 1...100 (значения от 1 до 99)
* **Time** - время
* **Date** - дата
* **Struct** - специфические классы, которые содержат только набор переменных и методы доступа к ним
* в Ruby используется динамическая типизация
* определить тип данных можно с помощью метода .class или метода .kind_of?(), в скобках указывается тип данных

### Преобразование типов данных
* допустим, у нас есть переменная name
* можно использовать метод преобразования в текстовый формат .to_s
* например, name.to_s 
* можно интерполировать переменную в текстовый формат, задав её в таком виде: "#{name}"
* .to_i - преобразование в Integer
* .to_f - преобразование во Float
* .to_s - преобразование в String
* .to_a - преобразование в Array
* .to_h - преобразование в Hash

### Вывод данных
* puts - команда выводит данные **в виде строки** и в конце печатает символ перевода строки; если просто написать puts, будет выведена отдельная пустая строка
* print - команда выводит данные, но в конце не добавляет символ новой строки
* p - команда выводит данные в наиболее "говорящем" виде
* после использования метода указать данные, которые нужно вывести
* конкатенация, puts "1" + "2" => "12"
* сложение, puts 1 + 2 => 12
* определение класса, puts "1".class => String, puts 1.class => Integer

### Переменные
* переменная задаётся с помощью оператора =

### Операторы
* '+'
* '-'
* '*'
* '/'
* '**' (возведение в степень, после оператора указать степень)
* '<'
* '>'
* '==' (равно)
* '!=' (не равно)
* '>='
* '<='
* puts 1<2 => true, puts 1>2 => false
* '+=' (инкремент, добавляет заданное значение)
* '-=' (декремент, отнимает заданное значение
* '.' (вызов метода)

### Изменение исходного объекта
* методы **не изменяют** исходный объект
* для **изменения** исходного объекта после названия метода нужно поставить "!"

### Методы работы со строками
* для работы со строками доступны следующие методы
* .length - определение длины строки; метод учитывает все символы в строке, включая буквы, числа, пробелы и символы
* .slice() - извлечение символа или диапазона символов из строки; строка индексируется, начиная с 0; в () можно, например, указать (0), (0,1), (0..7)
* можно вместо .slice() использовать псевдоним метода []
* получить доступ к символам в конце строки можно с помощью отрицательного индекса: -1 выведет последний символ строки, -2 выведет предпоследний
* .upcase - преобразование строки в верхний регистр
* .downcase - преобразование строки в нижний регистр
* .capitalize - переписывание первого слова в строке с заглавной буквы
* .swapcase - обращение регистра строки; заглавные буквы станут строчными, строчные - заглавными
* .center(), .ljust(), .rjust() - добавление пробелов с обеих сторон, слева или справа; в () указывается количество пробелов, которое нужно добавить
* чтобы добавить не пробелы, а определённые символы, можно указать в () через запятую количество символов, которое нужно добавить, и символ для добавления в ""
* .strip, .lstrip, .rstrip - удаление пробелов с обеих сторон, слева или справа
* .chop - удаление последнего символа строки (включая отступ, если он имеется)
* .chomp - удаление отступа; если отступа нет, вернёт исходную строку
* .chomp() - удаление последних символов с конца строки; в () указываются последние символы в ""
* .include?() - проверка наличия в строке искомой строки; в () указывается искомая строка в ""
* .index() - возвращение индекса искомого символа; в () указывается искомый символ в ""; метод находит только первое совпадение; при запросе несуществующего символа возвращает nil
* .start_with?() - проверка, начинается ли строка с искомой строки; в "" указывается искомая строка в ""
* .end_with?() - проверка, заканчивается ли строка искомой строкой; в "" указывается искомая строка в ""
* .sub() - замена части строки на другую; в () указываются через запятую старая часть строки и новая часть строки; метод заменяет только первое совпадение
* .gsub() - замена части строки на другую; в () указываются через запятую старая часть строки и новая часть строки; метод заменяет все совпадения
* .chars - преобразование строки в массив из её элементов (символов)
* .split - преобразование строки в массив из слов

### Методы работы со временем
* Time.now показывает текущее время
* Time.now.month показывает текущий месяц
* метод .strftime() преобразовывает информацию в необходимый формат
* %a - день недели (краткое название) (Sun)
* %A - день недели (полное название) (Sunday)
* %b - месяц (краткое название) (Jan)
* %B - месяц (полное название) (January)
* %d - день (01..31)
* %H - час (00..23)
* %I - час (01..12)
* %j - день года (001..366)
* %m - месяц (01..12)
* %M - минута (00..59)
* %p - индикатор меридиана (AM или PM)
* %S - секунда (00..59)
* %U - номер недели (начинается с ВС) (00..53)
* %W - номер недели (начинается с ПН) (00..53)
* %w - день недели (начинается с ВС) (0..6)
* %y - год (00..99)
* %Y - год
* %Z - название часового пояса
* в () можно комбинировать данные ключи и добавлять другую необходимую информацию
* например, t = Time.now / t.strftime("Printed on %d.%m.%Y") => "Printed on 04.09.2003"

### Логические операторы
* && - and - и
* || - or - или
* ! - not - не
* ^ - xor - исключающее или
* puts true && true => true
* puts true && false => false
* puts false && false => false
* puts true || true = true
* puts true || false = true
* puts false || false = false

### Условные выражения
* if - если
* elsif - если (другое условие)
* unless - пока не (если наоборот)
* else - иначе
* в конце ставится end

### Цикл while
* while - пока
* в конце ставится end
* сначала задаётся условие, потом цикл while ... end
* пример цикла: while i < 5 / puts i / end
* если условие выполняется всегда, то цикл будет бесконечным
* чтобы цикл не был бесконечным, используйте операторы '+=' и '-=' или запись типа i = i + 1 и i = i - 1

### Цикл for
* пример цикла: for i in 0..5 / puts i / end
* цикл выполняется, пока i находится в диапазоне от 0 до 5

### Методы
* метод задаётся командой def
* в конце ставится end
* метод можно вызвать с помощью его названия
* метод принимает аргументы в ()
* можно задать метод и сразу аргумент к нему, например: def method (name)
* вызвать такой метод можно сразу с заданным аргументом: method (name = 'Oleg') или method ('Oleg')
* метод можно включить внутрь другого метода
* можно задать метод сразу с несколькими аргументами к нему, например: def method (name, age, weight)
* можно определить значение аргумента по умолчанию, например: def method (name, age, weight = 70)
* но и для аргумента со значением по умолчанию можно это значение поменять при вызове метода, например: method ('Oleg', 25, 60)
* но такие аргументы со значением по умолчанию ставят **в конце**
* чтобы значение по умолчанию было не задано, нужно указать "" для текста или nil для числа

### Объекты и классы
* класс задаётся командой class
* в конце ставится end
* для создания объекта - экземпляра класса используется метод .new
* например, создаём class Item
* создаём объект - экземпляр класса item1 = Item.new
* под каждый объект выделяется оперативная память
* при вызове объекта можно увидеть его уникальный ключ, который при каждом новом вызове меняется
* объект класса имеет доступ к переменным и методам класса

### Свойства, сеттеры и геттеры
* свойство начинается со знака @
* сеттер записывает данные
* пример записи сеттера: def price=(value) / @price = value / end (знак = в сеттере должен стоять слитно, сразу после названия)
* геттер возвращает переменную и её свойства
* пример записи геттера: def price / @price / end
* метод def initialize инициализирует параметры при создании класса
* внутри этого метода можно задать значение переменных по умолчанию
* если нужно записать данные для нескольких переменных, можно использовать attr_writer (заменяет сеттер)
* если нужно возвратить несколько переменных, то можно использовать attr_reader (заменяет геттер)
* также можно использовать attr_accessor, он включает в себя возможности этих 2 команд
* пример использования: attr_accessor :salary, :graphic (знак : перед переменной, перечисление переменных через запятую)

### Символы, ассоциативные массивы и установка свойств
* символы начинаются с :
* символы в отличие от строки не меняются
* хэш - ассоциативный массив, задаётся с помощью {}
* хэш можно представить как массив пар "ключ - значение", но в отличие от массива хэш неупорядочен: нельзя сказать, как пара будет первой, какая последней
* пример записи хэша: dasha = {name: 'Dasha', age: 21}
* пример записи хэша: dasha = {:name => 'Dasha', :age => 21}
* вывести значения хэша можно так: p dasha[:name] / p dasha[:age]

### Массивы
* массивы объявляются в []
* пример записи массива: array = ['Dasha, 'Masha', 'Pasha']
* пример записи массива: array = %w[Dasha Masha Pasha]
* элементы массива начинаются с 0
* p array => ["Dasha", "Masha", "Pasha"]
* p array[0] => "Dasha", p array[1] => "Masha", p array[2] => "Pasha"

### Методы работы с массивами
* для работы с массивами доступны следующие методы
* Array.new(n){ |index| index + 1 } - создание нового массива [1, 2, 3, 4, 5 ... n ]
* (1..n).to_a - создание нового массива [1, 2, 3, 4, 5 ... n ]
* .empty? - проверка массива на отсутствие элементов
* .any? - проверка массива на наличие элементов
* .include?() - проверка наличия в массиве искомого элемента; в () указывается искомый элемент
* .size - возвращение размера массива
* .max - возвращение максимального элемента
* .min - возвращение минимального элемента
* .unshift - добавление нового элемента массива в начало массива; в () указывается новый элемент массива
* .push - добавление нового элемента массива в конец массива; в () указывается новый элемент массива
* .shift - удаление первого элемента массива
* .pop - удаление последнего элемента массива
* .sort - сортировка элементов
* .reverse - обращение массива
* .sort.reverse - сортировка массива по убыванию
* .uniq - удаление дубликатов
* .compact - удаление элементов nil
* .transpose - транспонирование многомерных массивов
* .find_index() - поиск индекса массива по значению; в () указывается значение элемента массива
* .map{} - изменение массива; в {} указывается блок, например, array.map{ |i| i**2 } возводит элементы массива в степень 2
* .find_all{} - поиск элементов массива по условию; в {} указывается блок с условием
* array.find_all{ |i| i.odd? } вернёт нечётные элементы массива
* array.find_all{ |i| i.even? } вернёт чётные элементы массива* 

### Методы работы с ассоциативными массивами
* для работы с ассоциативными массивами доступны следующие методы
* hash[:key] = :value - добавление нового элемент в ассоциативный массив
* .keys - возвращение ключей
* .values - возвращение значений
* .empty? - проверка ассоциативного массива на отсутствие элементов
* .key?() - проверка наличия в ассоциативном массиве искомого ключа; в () указывается искомый ключ
* .value?() - проверка наличия в ассоциативном массиве искомого значения; в () указывается искомое значение
* .size - возвращение размера ассоциативного массива
* .max - возвращение максимального элемента
* .min - возвращение минимального элемента
* .delete() - удаление элемента ассоциативного массива; в () указывается ключ
* .to_a - преобразование в массив
* .sort - преобразование в массив и сортировка
* .map{} - изменение ассоциативного массива; в {} указывается блок
* .find_all{} - поиск элементов ассоциативного массива по условию; в {} указывается блок с условием

### Запуск файлов .rb
* файлы .rb можно запустить командой require_relative
* пример: require_relative 'item' (название файла указывается без расширения и в '')
* можно запустить все файлы в папке одной командой
* например, Dir["*.rb"].each { |file| require_relative file if file != 'init.rb' }
* для класса Dir задаём аргумент - все файлы с расширением .rb и используем метод-итератор .each, который перебирает все файлы (далее в блоке задаём аргумент file и используем команду require_relative)
* чтобы рабочий файл не запускался дважды, прописываем дополнительное условие

### Итераторы
* итератор перебирает значения, например, элементы массива
* методы .map, .each - примеры итераторов
* пример использования: array.each {|name| puts name}
* пример использования: array.each do |name| / puts name / end
* если мы используем второй способ объявления метода, то мы можем внутри метода задать условие
* метод перебирает значения по порядку, задавая значение в || мы обозначаем этим элементы массива
* array.each {|name| puts name} => элементы массива по порядку, каждый элемент на отдельной строке

### Блоки
* блок является анонимным методом
* блоки начинаются с ключевого слова do и заканчиваются end
* или начаются с { и заканчиваются }
* блок принимает аргументы в ||
* сначала мы создаём метод, принимающий блок, например, def info / yield price / end, где команда yield принимает блок, а price - аргумент блока
* далее мы используем этот блок, например, item.info { |value| puts value }, где value - аргумент для вывода, в данном случае value = price
* метод block_given? проверяет, передан ли блок
* например, если просто указать item.info, то здесь использования блока нет, в отличие от item.info { |value| puts value }
* пример: def info / if block_given? / yield price / else / puts 'Nothing to show' / end / end
* пример использования блока без аргумента: 5.times {puts 'Hello Ruby'} => 5 строк Hello Ruby
* пример использовая блока: hash.each_key {|i| puts i} => названия (не значения!) аргументов хэша hash
* пример использования блока: @items.delete_if {|i| i.price.nil?} => будут удалены элементы items c параметром price = 0

### Ввод информации от пользователя
* для ввода информации от пользователя используется команда gets
* чтобы убрать отступ после введённого значения, используется метод .chop
* например, puts 'Enter your name' / name = gets / puts 'Hello, ' + name,chop + '!'

### Работа с файлами
* создадим пустой файл block.txt
* командой File.open("block.txt", "w") { |y| y.puts "Hello Ruby" } вводим в файл строку Hello Ruby
* командой File.open("block.txt", "a") { |y| y.puts "Hello Ruby" } вводим в файл строку Hello Ruby
* командой i = File.open("block.txt", "r") {|y| y.read } присваиваем переменной i содержание файла (читаем файл); модификатор доступа "r" указывать не обязательно, так как он устанавливается по умолчанию
* метод .readlines преобразует содержимое файла в массив со строками
* "w" означает внесение записи с предварительной очисткой файла
* "a" означает добавление записи в конец
* чтобы каждая новая запись начиналась с новой строки, нужно в конце записи добавлять \n (символ переноса на следующую строку)
* переменная y в блоке обозначает файл
* командой File.delete() удаляем файл; в () указывается название файла с расширением в ""

### Наследование и полиморфизм
* наследование предполагает что один объект приобретает свойства другого объекта; один класс приобретает свойства и методы другого класса
* полиморфизм - выполнение одного и того же действия разными способами; способность объекта использовать методы класса разными способами
* запись class VirtualItem < Item предполагает, что класс VirtualItem приобретает свойства и методы класса Item
* если мы для нового класса задаём дополнительные свойства и перезапускаем метод, то для того, чтобы были доступны свойства родительского класса, используем внутри метода команду super

### Методы и переменные класса
* если создать метод класса командой def self. (после . указать название метода), то мы можем использовать этот метод не на объекте, а на самом классе
* например, командой def self.discount создаём метод класса Item
* после этого мы можем использовать этот метод для самого класса, например, p Item.discount
* переменные класса начинаются с @@
* переменная класса может быть использована в любом методе класса

### Приватные методы
* приватный метод - метод, доступный только в самом классе
* перед объявлением приватного метода вставляем команду private (отдельной строкой)
* пример: private / def tax / ... / end

### Модули
* если в нескольких классах используются одни и те же методы и переменные, можно создать **модуль** с этими методами и переменными, а потом добавить этот модуль в соответствующие классы
* создание модуля начинается с команды module
* например, module ItemContainer
* добавление модуля внутри класса начинается с команды include
* например, include ItemContainer
* добавления вложенного модуля внутри класса начинается с команды include, а модуль и вложенный модуль разделяются ::
* например, include ItemContainer::Manager

### Callback на включение модуля
* данные команды используются, если нужно при добавлении модуля автоматически добавить вложенные модули
* для создания callback на включение модуля можно использовать следующие команды
* для того, чтобы методы модуля были доступны непосредственно через класс, создаём метод класса с аргументом и используем метод extend (далее указывается название вложенного модуля)
* например, def self.included (classes) / classes.extend ClassMethods
* для того, чтобы методы модуля добавлялись как экземпляр класса, создаём метод класса с аргументом и используем один из двух методов
* def self.included (classes) / classes.class_eval { include InstanceMethods }
* def self.included (classes) / classes.send :include, InstanceMethods

### Полезные методы работы с объектами
* return вызывает значение (можно не писать return в последней строке, так как значение в последней строке всегда возвращается)
* параллельное присваивание: a, b, c = 1, 2, 3
* p a ? b : c => если a == true => b, иначе => c
* .methods - возвращение списка доступных методов
* .class - возвращение класса объекта
* метод .nil? определяет, является ли переменная пустой
* rand вызывает случайное число в пределах выбранного числа (указать выбранное число)
* rand(m..n) - возвращение случайного числа от m до n включительно
