## Работа с Терминалом

### Команды
* clear - очистить экран от содержимого
* ls - показать файлы в папке
* cd - открыть папку (указать название папки)
* cd .. - открыть родительскую папку
* touch - создать новый файл (указать название файла и при необходимости указать расширение)
* клавиши ctrl + shift + x - сохранение изменений
* клавиша tab - дозаполнить текст, который вы недописали
* клавиши ВВЕРХ и ВНИЗ - перебор значений, которые мы вводили недавно
* клавиша q - выход в режим ввода, если он недоступен
* несколько команд можно объединить знаком &&, например, touch 1.rb && git add 1.rb && git commit -m "Commit 1"
* ruby - запустить программу (указать название файла с расширением .rb)
* irb - запустить интерактивную консоль Ruby (устанавливается вместе с Ruby)
* ./rubymine.sh - запуск редактора RubyMine

## Работа с Ruby

### Комментарий к курсу
* код в виде столбца будет здесь для удобства отображаться одной строкой, новая строка обозначается знаком /
* пример: def price=(value) / @price = value / end

### Вывод данных
* puts - метод выводит данные **в виде строки** и в конце печатает символ перевода строки
* print - метод выводит данные, но в конце не добавляет символ новой строки
* p - метод выводит данные в наиболее "говорящем" виде
* после использования метода указать данные, которые нужно вывести
* конкатенация, puts "1" + "2" => "12"
* сложение, puts 1 + 2 => 12
* определение класса, puts "1".class => String, puts 1.class => Integer

### Переменные
* переменная задаётся с помощью оператора =
* смотри [пример: Переменные](theory/variables.rb)

### Операторы
* '+'
* '-'
* '*'
* '/'
* '<'
* '>'
* '==' (равно)
* '!=' (не равно)
* '>='
* '<='
* puts 1<2 => true, puts 1>2 => false
* '+=' (инкремент, добавляет заданное значение)
* '-=' (декремент, отнимает заданное значение
* '.' (вызов метода)
* смотри [пример: Операторы](theory/operators.rb)

### Преобразование в строку
* допустим, у нас есть переменная name
* можно использовать метод преобразования в текстовый формат .to_s
* например, name.to_s 
* можно интерполировать переменную в текстовый формат, задав её в таком виде: "#{name}"

### Логические операторы
* && - и
* || - или
* puts true && true => true
* puts true && false => false
* puts false && false => false
* puts true || true = true
* puts true || false = true
* puts false || false = false
* смотри [пример: Операторы](theory/operators.rb)

### Условные выражения
* if - если
* elsif - если (другое условие)
* unless - пока не (если наоборот)
* else - иначе
* в конце ставится end
* смотри [пример: Условные выражения](theory/conditional.rb)

### Циклы
* while - пока
* в конце ставится end
* сначала задаётся условие, потом цикл while ... end
* пример цикла: while i < 5 / puts i / end
* если условие выполняется всегда, то цикл будет бесконечным
* чтобы цикл не был бесконечным, используйте операторы '+=' и '-=' или запись типа i = i + 1 и i = i - 1
* смотри [пример: Циклы](theory/cycles.rb)

### Методы
* метод задаётся командой def
* в конце ставится end
* метод можно вызвать с помощью его названия
* метод принимает аргументы в ()
* можно задать метод и сразу аргумент к нему, например: def method (name)
* вызвать такой метод можно сразу с заданным аргументом: method (name = 'Oleg') или method ('Oleg')
* метод можно включить внутрь другого метода
* можно задать метод сразу с несколькими аргументами к нему, например: def method (name, age, weight)
* можно определить значение аргумента по умолчанию, например: def method (name, age, weight = 70)
* но и для аргумента со значением по умолчанию можно это значение поменять при вызове метода, например: method ('Oleg', 25, 60)
* но такие аргументы со значением по умолчанию ставят **в конце**
* чтобы значение по умолчанию было не задано, нужно указать "" для текста или nil для числа
* смотри [пример: Методы](theory/methods.rb)

### Объекты и классы
* класс задаётся командой class
* в конце ставится end
* для создания объекта - экземпляра класса используется метод .new
* например, создаём class Item
* создаём объект - экземпляр класса item1 = Item.new
* под каждый объект выделяется оперативная память
* при вызове объекта можно увидеть его уникальный ключ, который при каждом новом вызове меняется
* объект класса имеет доступ к переменным и методам класса
* смотри [пример: Приём на работу](experiments/recruitment.rb)

### Полезные команды
* return вызывает значение
* rand вызывает случайное число в пределах выбранного числа (указать выбранное число)
* метод .nil? определяет, является ли переменная пустой
* Time.now показывает текущее время
* Time.now.month показывает текущий месяц

### Свойства, сеттеры и геттеры
* свойство начинается со знака @
* сеттер записывает данные
* пример записи сеттера: def price=(value) / @price = value / end (знак = в сеттере должен стоять слитно, сразу после названия)
* геттер возвращает переменную и её свойства
* пример записи геттера: def price / @price / end
* метод def initialize инициализирует параметры при создании класса
* внутри этого метода можно задать значение переменных по умолчанию
* если нужно записать данные для нескольких переменных, можно использовать attr_writer (заменяет сеттер)
* если нужно возвратить несколько переменных, то можно использовать attr_reader (заменяет геттер)
* также можно использовать attr_accessor, он включает в себя возможности этих 2 команд
* пример использования: attr_accessor :salary, :graphic (знак : перед переменной, перечисление переменных через запятую)
* смотри [пример: Приём на работу](experiments/recruitment.rb)
* смотри [пример: Интернет-магазин, корзина](online_store/cart.rb)

### Символы, хэши и установка свойств
* символы начинаются с :
* символы в отличие от строки не меняются
* хэш - ассоциативный массив, задаётся с помощью {}
* пример записи хэша: dasha = {name: 'Dasha', age: 21}
* пример записи хэша: dasha = {:name => 'Dasha', :age => 21}
* вывести значения хэша можно так: p dasha[:name] / p dasha[:age]
* смотри [пример: Хэши](theory/hash.rb)

### Массивы
* массивы объявляются в []
* пример записи массива: array = ['Dasha, 'Masha', 'Pasha']
* пример записи массива: array = %w[Dasha Masha Pasha]
* элементы массива начинаются с 0
* p array => ["Dasha", "Masha", "Pasha"]
* p array[0] => "Dasha", p array[1] => "Masha", p array[2] => "Pasha"
* метод .push добавляет новый элемент массива в конец массива (указать в скобках новый элемент массива)
* метод .pop удаляет последний элемент массива
* метод .shift удаляет первый элемент массива
* смотри [пример: Массивы](theory/array.rb)

### Запуск файлов .rb
* файлы .rb можно запустить командой require_relative
* пример: require_relative 'item' (название файла указывается без расширения и в '')
* можно запустить все файлы в папке одной командой
* например, Dir["*.rb"].each { |file| require_relative file if file != 'init.rb' }
* для класса Dir задаём аргумент - все файлы с расширением .rb и используем метод-итератор .each, который перебирает все файлы (далее в блоке задаём аргумент file и используем команду require_relative)
* чтобы рабочий файл не запускался дважды, прописываем дополнительное условие
* смотри [пример: Интернет-магазин, виртуальные товары](online_store/virtual_item.rb)
* смотри [пример: Интернет-магазин, обычные товары](online_store/real_item.rb)
* смотри [пример: Интернет-магазин](online_store/init.rb)

### Итераторы
* итератор перебирает значения, например, элементы массива
* метод .each - пример итератора
* пример использования: array.each {|name| puts name}
* пример использования: array.each do |name| / puts name / end
* если мы используем второй способ объявления метода, то мы можем внутри метода задать условие
* метод перебирает значения по порядку, задавая значение в || мы обозначаем этим элементы массива
* array.each {|name| puts name} => элементы массива по порядку, каждый элемент на отдельной строке
* смотри [пример: Блоки](theory/blocks.rb)

### Блоки
* блок является анонимным методом
* блоки начинаются с ключевого слова do и заканчиваются end
* или начаются с { и заканчиваются }
* блок принимает аргументы в ||
* сначала мы создаём метод, принимающий блок, например, def info / yield price / end, где команда yield принимает блок, а price - аргумент блока
* далее мы используем этот блок, например, item.info { |value| puts value }, где value - аргумент для вывода, в данном случае value = price
* метод block_given? проверяет, передан ли блок
* например, если просто указать item.info, то здесь использования блока нет, в отличие от item.info { |value| puts value }
* пример: def info / if block_given? / yield price / else / puts 'Nothing to show' / end / end
* пример использования блока без аргумента: 5.times {puts 'Hello Ruby'} => 5 строк Hello Ruby
* пример использовая блока: hash.each_key {|i| puts i} => названия (не значения!) аргументов хэша hash
* пример использования блока: @items.delete_if {|i| i.price.nil?} => будут удалены элементы items c параметром price = 0
* смотри [пример: Блоки](theory/blocks.rb)
* смотри [пример: Интернет-магазин, корзина](online_store/cart.rb)
* смотри [пример: Интернет-магазин, товары](online_store/item.rb)
* смотри [пример: Интернет-магазин](online_store/init.rb)

### Работа с файлами
* создадим пустой файл block.txt
* командой File.open("block.txt", "w") { |y| y.puts "Hello Ruby" } вводим в файл строку Hello Ruby
* "w" означает внесение записи
* переменная y в блоке обозначает файл
* по сути мы меняем содержимое файла на Hello Ruby
* смотри [пример: Блоки](theory/blocks.rb)

### Наследование и полиморфизм
* наследование предполагает что один объект приобретает свойства другого объекта; один класс приобретает свойства и методы другого класса
* полиморфизм - выполнение одного и того же действия разными способами; способность объекта использовать методы класса разными способами
* запись class VirtualItem < Item предполагает, что класс VirtualItem приобретает свойства и методы класса Item
* если мы для нового класса задаём дополнительные свойства и перезапускаем метод, то для того, чтобы были доступны свойства родительского класса, используем внутри метода команду super
* смотри [пример: Интернет-магазин, виртуальные товары](online_store/virtual_item.rb)
* смотри [пример: Интернет-магазин, обычные товары](online_store/real_item.rb)
* смотри [пример: Интернет-магазин, товары](online_store/item.rb)
* смотри [пример: Интернет-магазин](online_store/init.rb)

### Методы и переменные класса
* если создать метод класса командой def self. (после . указать название метода), то мы можем использовать этот метод не на объекте, а на самом классе
* например, командой def self.discount создаём метод класса Item
* после этого мы можем использовать этот метод для самого класса, например, p Item.discount
* переменные класса начинаются с @@
* переменная класса может быть использована в любом методе класса
* смотри [пример: Интернет-магазин, товары](online_store/item.rb)
* смотри [пример: Интернет-магазин](online_store/init.rb)
