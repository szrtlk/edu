## Работа с Терминалом

### Команды
* clear - очистить экран от содержимого
* ls - показать файлы в папке
* cd - открыть папку (указать название папки)
* cd .. - открыть родительскую папку
* touch - создать новый файл (указать название файла и при необходимости указать расширение)
* клавиши ctrl + shift + x - сохранение изменений
* клавиша tab - дозаполнить текст, который вы недописали
* клавиши ВВЕРХ и ВНИЗ - перебор значений, которые мы вводили недавно
* клавиша q - выход в режим ввода, если он недоступен
* несколько команд можно объединить знаком &&, например, touch 1.txt && git add . && git commit -m "Commit 1"

## Работа с Git

### Создание репозитория и первичная настройка
* открываем папку проекта (корневую папку репозитория)
* git init - инициализация Git, команда превращает папку в репозиторий
* git config --global user.name - задаём имя пользователя (указать имя пользователя в "")
* git config --global user.email - задаём электронную почту (указать электронную почту в "")
* git config --list - смотрим список изменений, там появятся имя пользователя и электронная почта

### Создание файла .gitignore
* touch .gitignore - создаём в папке проекта файл .gitignore (файл не имеет расширения!)
* в этом файле указываются файлы и папки, не подлежащие коммиту
* если вносится комментарий, то он начинается с #
* пример записи: folder/
* пример записи: folder/1.img
* пример записи: folder/*.img
* как правило, сюда вносятся изображения и прочие крупные файлы, которые не имеет смысл заливать на GitHub

### Проверка статуса
* git status - показывает статус проекта (папки / файлы с изменениями и новые папки / файлы в **папке проекта**, подлежащие коммиту)
* файлы и папки, указанные в файле .gitignore, отображаться не будут
* файлы во вложенных папках показаны не будут, будут показаны только папки и файлы в **папке проекта**
* git status --untracked-files=all - показывает новые файлы и файлы с изменения во **вложенных папках**, подлежащие коммиту

### Работа с коммитами
* git add - команда добавляет файл к будущему коммиту (указать название файла, с расширением!)
* git add . - команда добавляет все файлы (кроме игнорируемых) к будущему коммиту
* если изменения не внесены, то коммит не пройдёт
* git commit -m "Initial commit" - команда производит коммит, последняя часть в "" - название коммита, его можно менять
* git commit --amend - команда открывает меню редактирования коммита, в этом меню можно поменять название коммита, а можно просто сохранить, эта команда позволяет не создавать новый коммит, а откорректировать предыдущий (включить новые файлы или файлы с изменениями)
* git log - команда открывает список коммитов
* каждый коммит имеет уникальный ключ из большого количества символов, но для вызова коммита достаточно ввести первые 4-6 символов
* git checkout - команда открывает коммит (указать первые символы уникального ключа коммита)
* git checkout master - команда возвращает в процесс редактирования (это не последний сохранённый коммит, а именно процесс редактирования)
* при переименование файла Git считает, что файл со старым названием удалён, а файл с новым названием создан, переименованный файл как новый нужно добавить командой git add
* git diff - команда показывает наличие разницы между текущей версией и последней сохранённой версией, если изменений нет, ничего не выдаёт
* git log --pretty=format:"%h - %an, %ar : %s" - команда выведет краткий список коммитов
* git log --since=1.week - команда выведет лог за неделю
* git log -p -2 - команда выведет историю изменения 
* git log --graph - команда выведет историю лога в графическом виде

### Создание веток
* git branch - команда выводит список веток, который у нас есть
* git branch - команда создаёт новую ветку (указать название ветки на латинице без пробелов в "")
* git switch - команда переключает на указанную ветку (указать название ветки)
* git checkout - команда переключает на указанную ветку (указать название ветки)
* таким образом, команда git checkout переключает как на отдельный коммит (если указать первые символы уникального ключа коммита), так и на отдельную ветку (если указать название ветки)
* git checkout -b - команда создаёт новую ветку и сразу на неё переключает (указать название ветки на латинице без пробелов в "")
* лог предоставляется только для той ветки, с которой сейчас работаем
* у каждой ветки своя история коммитов, например

### Объединение веток (мерж)
* git merge - команда добавляет в открытую ветку коммиты той ветки, которую вы укажете, то есть происходит мерж (указать название ветки, коммиты которой хотите добавить)
* если при мерже возник конфликт, то это будет указано в сообщении после использовании команды
* пример конфликта - в файле в одном месте была отредактирована информация и в открытой ветке, и в ветке, которую хотели смержить
* например, в программе Visual Studio предлагается 4 варианта для выбора: оставить имеющийся вариант, оставить новый вариант, оставить оба варианта, сравнить оба варианта
* после принятия решения и корректировки файла нужно повторить коммит, т.к. информация после мержа добавилась, а коммит не прошёл
* если произошёл конфликт, то использовать команду git rebase --interactive HEAD~4 небезопасно

### Удаление веток
* git branch -d - команда удаляет ветку, но только в том случае, если содержимое ветки перенесено в ветку мастера, то есть произошёл мерж (указать название ветки)
* git branch -D - команда удаляет ветку в любом случае (указать название ветки)

### Rebase
* rebase (перебазирование) - один из способов, позволяющий объединить изменения двух веток. У этого способа есть преимущество перед merge (слияние) - он позволяет переписать историю ветки, придав тот истории тот вид, который нам нужен
* git rebase master - команда вносит в выбранную ветку изменения, который были сделаны в основной ветке, но не отражены в выбранной ветке
* структура лога выбранной ветки после rebase не древовидная, а линейная, недостающие коммиты основной ветки органично встроились в выбранную ветку
* так в дальнейшем снижается вероятность конфликта
* если мерж произвести после такого rebase одной из веток, то структура лога основной ветки будет не древовидной, а линейной
* не рекомендуется делать древовидную структуру, то есть надо для дочерней ветки создать rebase, потом в основной ветке сделать мерж, тогда обе ветки будут иметь одинаковую линейную структуру
* если в основную ветку снова вносятся изменения, то в дочерней ветке опять можно сделать rebase и так далее
* git rebase --interactive HEAD~4 - команда показывает информацию по последним 4 коммитам в ветке
* появляется список коммитов и с помощью команд из инструкции ниже эти коммиты можно обрабатывать
* например, для переименования коммита - вместо pick ставим reword
* например, для объединения 3 коммитов в один 2 последних коммита корректируем в списке - вместо pick ставим squash

### Stash
* команда git stash позволяет на время «сдать в архив» (или отложить) изменения, сделанные в рабочей копии, чтобы вы могли применить их позже
* git stash - команда добавляет изменение в stash (предварительно добавить файлы командой git add)
* git stash list - команда показывает список изменений в stash
* git stash pop - команда возвращает файлы из stash в работу

### Прочие команды
* git reset --hard - команда откатывает основную ветку к указанному коммиту, результаты мержа обнуляются (указать первые символы уникального ключа коммита)
* git restore - команда отменяет изменения после проведения коммита (указать названия файла, в котором нужно отменить изменения)
* git revert - команда удаляет последние изменения, но коммиты оставляет
* git reflog - команда показывает историю состояний с репозиторием (включая rebase и reset)
* каждое состояние имеет уникальный ключ
* git reflog - команда возвращает нас к выбранному состоянию (указать уникальный ключ состояния) 

## Работа с GitHub

### Заливка репозитория на GitHub
* git remote - команда показывает наличие репозитория на GitHub
* git remote remove origin - команда удаляет репозиторий с GitHub
* создаём аккаунт на GitHub
* создаём токен, который будет использоваться вместо пароля для подтверждения некоторых команд
* создаём репозиторий на GitHub
* git remote add origin - команда привязывает репозиторий на компьютере к репозиторию на GitHub (указать ссылку на репозиторий на GitHub)
* git branch -M main - команда переименовывает основную ветку с master на main
* git push -u origin main - команда заливает репозиторий на компьютере на GitHub
* git push - команда обновляет репозиторий на GitHub, заливает обновления из репозитория на компьютере
* перед заливкой обновлений на GitHub надо добавить файлы командой git add и создать коммит командой git commit
* после использования команды push нужно указать имя аккаунта на GitHub и пароль (токен)
* в репозитории на GitHub могут быть внесены изменения как напрямую на сайте, так и в результате заливки с другого компьютера
* git pull - команда заливает изменения с репозитория на GitHub в репозиторий на компьютере
* эта команда является составной, она также предполагает мерж основной ветки в репозитории на компьютере и основной ветки в репозитории на GitHub

### Копирование репозитория с GitHub
* создаём папку проекта на компьютере
* копируем адрес репозитория на GitHub, нажав на кнопку Code
* командой git status проверяем, что git не инициализирован
* git clone - команда копирует репозиторий с GitHub на компьютер (указать скопированный адрес репозитория на GitHub)
* после использования команды папка репозитория будет внутри папки проекта

### Работа с публичным репозиторием на GitHub
* открываем публичный репозиторий на GitHub
* копируем с помощью кнопки Fork репозиторий в наш аккаунт
* копируем репозиторий на наш компьютер с помощью команды git clone
* создаём новую ветку для внесения наших изменений (git branch)
* проводим коммит (git commit)
* заливаем изменения из репозитория на компьютере в репозиторий на GitHub (git push)
* при заливке ветки с изменениями на GitHUb нужно использовать команду git push --set-upstream origin (указать название ветки)
* отправляем наши изменения владельцу оригинального репозитория с помощью кнопки Compare & Pull Request
